算法班第三次课

2014-04-27

tri树： n叉树；最近公共祖先。字符串检索。查找字符串。
后缀树： 将所有后缀加入trie中，进行路径压缩。


234树：插入？每次插入到最底层，然后看是否符合2，3，4的条件，之后进行调整。

红黑树：删除存疑。

==========================
曹鹏cs：

树：无环联通图，（无向）
只要有一种递归结构就会有一个树对应，可能这个树没有什么意义。
镜像，同构，根据遍历还原树。
线段树，区间上维护一个值。区间更新比较复杂。建立o（n）查询nlog(n)
trie算是一种变相的hash。实现简单。
splay tree。
java的map set是基于hash。c++ 中使用rb tree。
Van Emde Boas 树，找出一个集合set中的某个点得前驱后继很快。

题目：
1 给出中序，前序遍历，还原树。
2 判断平衡。def hight(): return (root==NULL)?0:max(height(root->left),height(root->right))+1
def is_balance: return (root==NUll)|| ....
3 判断镜像。左右子树互换，ismirror: ...
4 判断是否为二叉搜索树。中序遍历记录子树最大，最小值。判断根节点的值是否大于左子树的最大值和友子树的最小值。
5 给定二叉树搜索树的前序遍历，还原二叉树。
6 给定n个整数集合。实现操作removeNUM（x）,query（x）查找x的后继。以及init(x).使用bool数组可以实现。
使用并查集： 删除x等价于union(x,x+1),
init(N) {
    for (i==;i<N;i++){
        f[i]=i

    }


}
remove(x) {
    union(x,x+1)
    注意路径压缩
}
find(x) {
    return     head(x)
}

7 线段树：完全二叉树；每个节点代表一个线段。（开闭区间无所谓）。
维护一个值，通常是该区间上的最大最小值。也可以维护区间和。
    动态单点更新等适合使用线段树。每次只更新某个节点的值，求更新后的值（最大，小，区间和）
    离散化：没有必要维护真正的值。10^5个整数，范围1-10^9，只需要维护10^5个线段就可以了。
    建立复杂度o(n): n+n/2+n/4 + ... <= 2n.高度为nlg(n).
    替代品：RMQ。 min[x][k]. min[x][0]=x ,min[x][k+1]=min (min[x+2^k][k],min[x][k]). ex: [3,13] ,1==2#1011 min[3,13] = min[3][3] ,min[11][1],min[13][0]
    实现代码简单，更新较麻烦。
8 赛车表示为三元组（id,start-time,end-time）查询有多少赛出比当前赛出出发晚但是早到达。得到分数。
按照升序排序（按照上面的分值）。
    逆序数可以是一个例子，但是也不太好办。
    首先按照start时间排序。倒序，维护线段树，中的车都比他开始的晚。
    查找（end，无穷）有多少个车数目就是这个车的分数。

根号n大法。
取桶的大小sqrt(n),或者n^(2/3)

9 点树：线段树的替代。
数据范围[0,n-1],插入删除简单
只能查找比某个数大的数目或者小得。

10：给定线段，图若干颜色。每次告诉你【x，y】图上某种颜色。后图上的覆盖前面涂的。
求每个颜色的覆盖长度。
11 trie：数可能很高。空间利用率不高，例如几千万单词。
    压缩，某个节点合并。
    复杂度正比于单词长度。
    权衡：hash和trie进行选择。单词数量，前缀共享情况。最大长度。

12 搜索引擎：如何存储，如何分布：slave，master，p2p（需要广播）
    如何更新，
    中文如何处理：转成拼音？
    不应该使用26个字母作为
    用途：最长前缀匹配。

13 线段树区间更新。不能为某个单点分别更新，加上字段lazy。传递到孩子。
14 lca，二叉树最近公共祖先。
    有没有父亲指针。有：便利一遍，计算长度差。
    没有：深度遍历，计算长度。1234567，1278.


15 迪卡树
    圣者败者树
    dfs，bfs的数：最小生成树。
    最短路径树。

曹鹏qq： 529929033


